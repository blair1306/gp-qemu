<dec f='codebrowser/slirp/slirp.h' l='285' type='void tcp_respond(struct tcpcb * , struct tcpiphdr * , struct mbuf * , tcp_seq , tcp_seq , int , unsigned short )'/>
<use f='codebrowser/slirp/tcp_input.c' l='670' u='c' c='tcp_input'/>
<use f='codebrowser/slirp/tcp_input.c' l='1392' u='c' c='tcp_input'/>
<use f='codebrowser/slirp/tcp_input.c' l='1395' u='c' c='tcp_input'/>
<def f='codebrowser/slirp/tcp_subr.c' l='127' ll='238' type='void tcp_respond(struct tcpcb * tp, struct tcpiphdr * ti, struct mbuf * m, tcp_seq ack, tcp_seq seq, int flags, unsigned short af)'/>
<doc f='codebrowser/slirp/tcp_subr.c' l='114'>/*
 * Send a single message to the TCP at address specified by
 * the given TCP/IP header.  If m == 0, then we make a copy
 * of the tcpiphdr at ti and send directly to the addressed host.
 * This is used to force keep alive messages out using the TCP
 * template for a connection tp-&gt;t_template.  If flags are given
 * then we send a message back to the TCP which originated the
 * segment ti, and discard the mbuf containing it and any other
 * attached mbufs.
 *
 * In any case the ack and sequence number of the transmitted
 * segment are as specified by the parameters.
 */</doc>
<use f='codebrowser/slirp/tcp_timer.c' l='280' u='c' c='tcp_timers'/>
