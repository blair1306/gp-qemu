<dec f='codebrowser/slirp/mbuf.h' l='103' type='struct mbuf * m_get(Slirp * )'/>
<use f='codebrowser/slirp/bootp.c' l='179' u='c' c='bootp_reply'/>
<use f='codebrowser/slirp/dhcpv6.c' l='128' u='c' c='dhcpv6_info_request'/>
<use f='codebrowser/slirp/ip6_icmp.c' l='48' u='c' c='icmp6_send_echoreply'/>
<use f='codebrowser/slirp/ip6_icmp.c' l='85' u='c' c='icmp6_send_error'/>
<use f='codebrowser/slirp/ip6_icmp.c' l='144' u='c' c='ndp_send_ra'/>
<use f='codebrowser/slirp/ip6_icmp.c' l='231' u='c' c='ndp_send_ns'/>
<use f='codebrowser/slirp/ip6_icmp.c' l='272' u='c' c='ndp_send_na'/>
<use f='codebrowser/slirp/ip_icmp.c' l='282' u='c' c='icmp_send_error'/>
<use f='codebrowser/slirp/ip_input.c' l='255' u='c' c='ip_reass'/>
<use f='codebrowser/slirp/ip_output.c' l='116' u='c' c='ip_output'/>
<def f='codebrowser/slirp/mbuf.c' l='65' ll='98' type='struct mbuf * m_get(Slirp * slirp)'/>
<doc f='codebrowser/slirp/mbuf.c' l='57'>/*
 * Get an mbuf from the free list, if there are none
 * allocate one
 *
 * Because fragmentation can occur if we alloc new mbufs and
 * free old mbufs, we mark all mbufs above mbuf_thresh as M_DOFREE,
 * which tells m_free to actually g_free() it
 */</doc>
<use f='codebrowser/slirp/slirp.c' l='857' u='c' c='slirp_input'/>
<use f='codebrowser/slirp/socket.c' l='540' u='c' c='sorecvfrom'/>
<use f='codebrowser/slirp/tcp_output.c' l='297' u='c' c='tcp_output'/>
<use f='codebrowser/slirp/tcp_output.c' l='317' u='c' c='tcp_output'/>
<use f='codebrowser/slirp/tcp_subr.c' l='145' u='c' c='tcp_respond'/>
<use f='codebrowser/slirp/tftp.c' l='178' u='c' c='tftp_send_oack'/>
<use f='codebrowser/slirp/tftp.c' l='207' u='c' c='tftp_send_error'/>
<use f='codebrowser/slirp/tftp.c' l='234' u='c' c='tftp_send_next_block'/>
