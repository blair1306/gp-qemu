<dec f='codebrowser/tcg/tcg.h' l='325' type='4'/>
<use f='codebrowser/tcg/tcg.h' l='326' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='334' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='335' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='336' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='337' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='338' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='339' u='r'/>
<use f='codebrowser/tcg/tcg.h' l='389' u='r' c='get_alignment_bits'/>
<doc f='codebrowser/tcg/tcg.h' l='307'>/* MO_UNALN accesses are never checked for alignment.
     * MO_ALIGN accesses will result in a call to the CPU&apos;s
     * do_unaligned_access hook if the guest address is not aligned.
     * The default depends on whether the target CPU defines ALIGNED_ONLY.
     *
     * Some architectures (e.g. ARMv8) need the address which is aligned
     * to a size more than the size of the memory access.
     * Some architectures (e.g. SPARCv9) need an address which is aligned,
     * but less strictly than the natural alignment.
     *
     * MO_ALIGN supposes the alignment size is the size of a memory access.
     *
     * There are three options:
     * - unaligned access permitted (MO_UNALN).
     * - an alignment to the size of an access (MO_ALIGN);
     * - an alignment to a specified size, which may be more or less than
     *   the access size (MO_ALIGN_x where &apos;x&apos; is a size in bytes);
     */</doc>
<use f='codebrowser/tcg/tcg.c' l='1034' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1039' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1040' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1042' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1043' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1044' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1045' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1046' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1047' u='r'/>
<use f='codebrowser/tcg/tcg.c' l='1153' u='r' c='tcg_dump_ops'/>
