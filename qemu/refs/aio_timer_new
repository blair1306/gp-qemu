<def f='codebrowser/include/block/aio.h' l='403' ll='408' type='QEMUTimer * aio_timer_new(AioContext * ctx, QEMUClockType type, int scale, QEMUTimerCB * cb, void * opaque)'/>
<doc f='codebrowser/include/block/aio.h' l='387'>/**
 * aio_timer_new:
 * @ctx: the aio context
 * @type: the clock type
 * @scale: the scale
 * @cb: the callback to call on timer expiry
 * @opaque: the opaque pointer to pass to the callback
 *
 * Allocate a new timer attached to the context @ctx.
 * The function is responsible for memory allocation.
 *
 * The preferred interface is aio_timer_init. Use that
 * unless you really need dynamic memory allocation.
 *
 * Returns: a pointer to the new timer
 */</doc>
<use f='codebrowser/block/iscsi.c' l='1533' u='c' c='iscsi_attach_aio_context'/>
<use f='codebrowser/block/iscsi.c' l='1541' u='c' c='iscsi_attach_aio_context'/>
<use f='codebrowser/block/qcow2.c' l='706' u='c' c='cache_clean_timer_init'/>
<use f='codebrowser/block/qed.c' l='353' u='c' c='bdrv_qed_attach_aio_context'/>
<use f='codebrowser/util/qemu-coroutine-sleep.c' l='37' u='c' c='co_aio_sleep_ns'/>
<use f='codebrowser/util/throttle.c' l='188' u='c' c='throttle_timers_attach_aio_context'/>
<use f='codebrowser/util/throttle.c' l='190' u='c' c='throttle_timers_attach_aio_context'/>
