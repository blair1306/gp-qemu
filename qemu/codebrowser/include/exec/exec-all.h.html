<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>exec-all.h source code [codebrowser/include/exec/exec-all.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="TranslationBlock "/>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/include/exec/exec-all.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>codebrowser</a>/<a href='..'>include</a>/<a href='./'>exec</a>/<a href='exec-all.h.html'>exec-all.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * internal execution defines for qemu</i></td></tr>
<tr><th id="3">3</th><td><i> *</i></td></tr>
<tr><th id="4">4</th><td><i> *  Copyright (c) 2003 Fabrice Bellard</i></td></tr>
<tr><th id="5">5</th><td><i> *</i></td></tr>
<tr><th id="6">6</th><td><i> * This library is free software; you can redistribute it and/or</i></td></tr>
<tr><th id="7">7</th><td><i> * modify it under the terms of the GNU Lesser General Public</i></td></tr>
<tr><th id="8">8</th><td><i> * License as published by the Free Software Foundation; either</i></td></tr>
<tr><th id="9">9</th><td><i> * version 2 of the License, or (at your option) any later version.</i></td></tr>
<tr><th id="10">10</th><td><i> *</i></td></tr>
<tr><th id="11">11</th><td><i> * This library is distributed in the hope that it will be useful,</i></td></tr>
<tr><th id="12">12</th><td><i> * but WITHOUT ANY WARRANTY; without even the implied warranty of</i></td></tr>
<tr><th id="13">13</th><td><i> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</i></td></tr>
<tr><th id="14">14</th><td><i> * Lesser General Public License for more details.</i></td></tr>
<tr><th id="15">15</th><td><i> *</i></td></tr>
<tr><th id="16">16</th><td><i> * You should have received a copy of the GNU Lesser General Public</i></td></tr>
<tr><th id="17">17</th><td><i> * License along with this library; if not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.</i></td></tr>
<tr><th id="18">18</th><td><i> */</i></td></tr>
<tr><th id="19">19</th><td></td></tr>
<tr><th id="20">20</th><td><u>#<span data-ppcond="20">ifndef</span> <span class="macro" data-ref="_M/EXEC_ALL_H">EXEC_ALL_H</span></u></td></tr>
<tr><th id="21">21</th><td><u>#define <dfn class="macro" id="_M/EXEC_ALL_H" data-ref="_M/EXEC_ALL_H">EXEC_ALL_H</dfn></u></td></tr>
<tr><th id="22">22</th><td></td></tr>
<tr><th id="23">23</th><td><u>#include <a href="../qemu-common.h.html">"qemu-common.h"</a></u></td></tr>
<tr><th id="24">24</th><td><u>#include <a href="tb-context.h.html">"exec/tb-context.h"</a></u></td></tr>
<tr><th id="25">25</th><td></td></tr>
<tr><th id="26">26</th><td><i>/* allow to see translation results - the slowdown should be negligible, so we leave it */</i></td></tr>
<tr><th id="27">27</th><td><u>#define <dfn class="macro" id="_M/DEBUG_DISAS" data-ref="_M/DEBUG_DISAS">DEBUG_DISAS</dfn></u></td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><i>/* Page tracking code uses ram addresses in system mode, and virtual</i></td></tr>
<tr><th id="30">30</th><td><i>   addresses in userspace mode.  Define tb_page_addr_t to be an appropriate</i></td></tr>
<tr><th id="31">31</th><td><i>   type.  */</i></td></tr>
<tr><th id="32">32</th><td><u>#<span data-ppcond="32">if</span> defined(<span class="macro" data-ref="_M/CONFIG_USER_ONLY">CONFIG_USER_ONLY</span>)</u></td></tr>
<tr><th id="33">33</th><td><b>typedef</b> abi_ulong tb_page_addr_t;</td></tr>
<tr><th id="34">34</th><td><u>#<span data-ppcond="32">else</span></u></td></tr>
<tr><th id="35">35</th><td><b>typedef</b> <a class="typedef" href="cpu-common.h.html#ram_addr_t" title='ram_addr_t' data-type='uintptr_t' data-ref="ram_addr_t">ram_addr_t</a> <dfn class="typedef" id="tb_page_addr_t" title='tb_page_addr_t' data-type='ram_addr_t' data-ref="tb_page_addr_t">tb_page_addr_t</dfn>;</td></tr>
<tr><th id="36">36</th><td><u>#<span data-ppcond="32">endif</span></u></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><i>/* DisasContext is_jmp field values</i></td></tr>
<tr><th id="39">39</th><td><i> *</i></td></tr>
<tr><th id="40">40</th><td><i> * is_jmp starts as DISAS_NEXT. The translator will keep processing</i></td></tr>
<tr><th id="41">41</th><td><i> * instructions until an exit condition is reached. If we reach the</i></td></tr>
<tr><th id="42">42</th><td><i> * exit condition and is_jmp is still DISAS_NEXT (because of some</i></td></tr>
<tr><th id="43">43</th><td><i> * other condition) we simply "jump" to the next address.</i></td></tr>
<tr><th id="44">44</th><td><i> * The remaining exit cases are:</i></td></tr>
<tr><th id="45">45</th><td><i> *</i></td></tr>
<tr><th id="46">46</th><td><i> *   DISAS_JUMP    - Only the PC was modified dynamically (e.g computed)</i></td></tr>
<tr><th id="47">47</th><td><i> *   DISAS_TB_JUMP - Only the PC was modified statically (e.g. branch)</i></td></tr>
<tr><th id="48">48</th><td><i> *</i></td></tr>
<tr><th id="49">49</th><td><i> * In these cases as long as the PC is updated we can chain to the</i></td></tr>
<tr><th id="50">50</th><td><i> * next TB either by exiting the loop or looking up the next TB via</i></td></tr>
<tr><th id="51">51</th><td><i> * the loookup helper.</i></td></tr>
<tr><th id="52">52</th><td><i> *</i></td></tr>
<tr><th id="53">53</th><td><i> *   DISAS_UPDATE  - CPU State was modified dynamically</i></td></tr>
<tr><th id="54">54</th><td><i> *</i></td></tr>
<tr><th id="55">55</th><td><i> * This covers any other CPU state which necessities us exiting the</i></td></tr>
<tr><th id="56">56</th><td><i> * TCG code to the main run-loop. Typically this includes anything</i></td></tr>
<tr><th id="57">57</th><td><i> * that might change the interrupt state.</i></td></tr>
<tr><th id="58">58</th><td><i> *</i></td></tr>
<tr><th id="59">59</th><td><i> * Individual translators may define additional exit cases to deal</i></td></tr>
<tr><th id="60">60</th><td><i> * with per-target special conditions.</i></td></tr>
<tr><th id="61">61</th><td><i> */</i></td></tr>
<tr><th id="62">62</th><td><u>#define <dfn class="macro" id="_M/DISAS_NEXT" data-ref="_M/DISAS_NEXT">DISAS_NEXT</dfn>    0 /* next instruction can be analyzed */</u></td></tr>
<tr><th id="63">63</th><td><u>#define <dfn class="macro" id="_M/DISAS_JUMP" data-ref="_M/DISAS_JUMP">DISAS_JUMP</dfn>    1 /* only pc was modified dynamically */</u></td></tr>
<tr><th id="64">64</th><td><u>#define <dfn class="macro" id="_M/DISAS_TB_JUMP" data-ref="_M/DISAS_TB_JUMP">DISAS_TB_JUMP</dfn> 2 /* only pc was modified statically */</u></td></tr>
<tr><th id="65">65</th><td><u>#define <dfn class="macro" id="_M/DISAS_UPDATE" data-ref="_M/DISAS_UPDATE">DISAS_UPDATE</dfn>  3 /* cpu state was modified dynamically */</u></td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><u>#include <a href="../qemu/log.h.html">"qemu/log.h"</a></u></td></tr>
<tr><th id="68">68</th><td></td></tr>
<tr><th id="69">69</th><td><em>void</em> <dfn class="decl" id="gen_intermediate_code" title='gen_intermediate_code' data-ref="gen_intermediate_code">gen_intermediate_code</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="59cpu" title='cpu' data-type='CPUState *' data-ref="59cpu">cpu</dfn>, <b>struct</b> <a class="type" href="#TranslationBlock" title='TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col0 decl" id="60tb" title='tb' data-type='struct TranslationBlock *' data-ref="60tb">tb</dfn>);</td></tr>
<tr><th id="70">70</th><td><em>void</em> <dfn class="decl" id="restore_state_to_opc" title='restore_state_to_opc' data-ref="restore_state_to_opc">restore_state_to_opc</dfn>(<a class="macro" href="../../target/i386/cpu.h.html#51" title="struct CPUX86State" data-ref="_M/CPUArchState">CPUArchState</a> *<dfn class="local col1 decl" id="61env" title='env' data-type='struct CPUX86State *' data-ref="61env">env</dfn>, <b>struct</b> <a class="type" href="#TranslationBlock" title='TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col2 decl" id="62tb" title='tb' data-type='struct TranslationBlock *' data-ref="62tb">tb</dfn>,</td></tr>
<tr><th id="71">71</th><td>                          <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> *<dfn class="local col3 decl" id="63data" title='data' data-type='target_ulong *' data-ref="63data">data</dfn>);</td></tr>
<tr><th id="72">72</th><td></td></tr>
<tr><th id="73">73</th><td><em>void</em> <dfn class="decl" id="cpu_gen_init" title='cpu_gen_init' data-ref="cpu_gen_init">cpu_gen_init</dfn>(<em>void</em>);</td></tr>
<tr><th id="74">74</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="cpu_restore_state" title='cpu_restore_state' data-ref="cpu_restore_state">cpu_restore_state</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="64cpu" title='cpu' data-type='CPUState *' data-ref="64cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col5 decl" id="65searched_pc" title='searched_pc' data-type='uintptr_t' data-ref="65searched_pc">searched_pc</dfn>);</td></tr>
<tr><th id="75">75</th><td></td></tr>
<tr><th id="76">76</th><td><em>void</em> <a class="macro" href="../qemu/compiler.h.html#25" title="__attribute__ ((__noreturn__))" data-ref="_M/QEMU_NORETURN">QEMU_NORETURN</a> <a class="decl" href="../../accel/tcg/cpu-exec-common.c.html#cpu_loop_exit_noexc" title='cpu_loop_exit_noexc' data-ref="cpu_loop_exit_noexc" id="cpu_loop_exit_noexc">cpu_loop_exit_noexc</a>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col6 decl" id="66cpu" title='cpu' data-type='CPUState *' data-ref="66cpu">cpu</dfn>);</td></tr>
<tr><th id="77">77</th><td><em>void</em> <a class="macro" href="../qemu/compiler.h.html#25" title="__attribute__ ((__noreturn__))" data-ref="_M/QEMU_NORETURN">QEMU_NORETURN</a> <dfn class="decl" id="cpu_io_recompile" title='cpu_io_recompile' data-ref="cpu_io_recompile">cpu_io_recompile</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col7 decl" id="67cpu" title='cpu' data-type='CPUState *' data-ref="67cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col8 decl" id="68retaddr" title='retaddr' data-type='uintptr_t' data-ref="68retaddr">retaddr</dfn>);</td></tr>
<tr><th id="78">78</th><td><a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="decl" id="tb_gen_code" title='tb_gen_code' data-ref="tb_gen_code">tb_gen_code</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="69cpu" title='cpu' data-type='CPUState *' data-ref="69cpu">cpu</dfn>,</td></tr>
<tr><th id="79">79</th><td>                              <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col0 decl" id="70pc" title='pc' data-type='target_ulong' data-ref="70pc">pc</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col1 decl" id="71cs_base" title='cs_base' data-type='target_ulong' data-ref="71cs_base">cs_base</dfn>,</td></tr>
<tr><th id="80">80</th><td>                              <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col2 decl" id="72flags" title='flags' data-type='uint32_t' data-ref="72flags">flags</dfn>,</td></tr>
<tr><th id="81">81</th><td>                              <em>int</em> <dfn class="local col3 decl" id="73cflags" title='cflags' data-type='int' data-ref="73cflags">cflags</dfn>);</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td><em>void</em> <a class="macro" href="../qemu/compiler.h.html#25" title="__attribute__ ((__noreturn__))" data-ref="_M/QEMU_NORETURN">QEMU_NORETURN</a> <a class="decl" href="../../accel/tcg/cpu-exec-common.c.html#cpu_loop_exit" title='cpu_loop_exit' data-ref="cpu_loop_exit" id="cpu_loop_exit">cpu_loop_exit</a>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="74cpu" title='cpu' data-type='CPUState *' data-ref="74cpu">cpu</dfn>);</td></tr>
<tr><th id="84">84</th><td><em>void</em> <a class="macro" href="../qemu/compiler.h.html#25" title="__attribute__ ((__noreturn__))" data-ref="_M/QEMU_NORETURN">QEMU_NORETURN</a> <a class="decl" href="../../accel/tcg/cpu-exec-common.c.html#cpu_loop_exit_restore" title='cpu_loop_exit_restore' data-ref="cpu_loop_exit_restore" id="cpu_loop_exit_restore">cpu_loop_exit_restore</a>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col5 decl" id="75cpu" title='cpu' data-type='CPUState *' data-ref="75cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col6 decl" id="76pc" title='pc' data-type='uintptr_t' data-ref="76pc">pc</dfn>);</td></tr>
<tr><th id="85">85</th><td><em>void</em> <a class="macro" href="../qemu/compiler.h.html#25" title="__attribute__ ((__noreturn__))" data-ref="_M/QEMU_NORETURN">QEMU_NORETURN</a> <a class="decl" href="../../accel/tcg/cpu-exec-common.c.html#cpu_loop_exit_atomic" title='cpu_loop_exit_atomic' data-ref="cpu_loop_exit_atomic" id="cpu_loop_exit_atomic">cpu_loop_exit_atomic</a>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col7 decl" id="77cpu" title='cpu' data-type='CPUState *' data-ref="77cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col8 decl" id="78pc" title='pc' data-type='uintptr_t' data-ref="78pc">pc</dfn>);</td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td><u>#<span data-ppcond="87">if</span> !defined(<span class="macro" data-ref="_M/CONFIG_USER_ONLY">CONFIG_USER_ONLY</span>)</u></td></tr>
<tr><th id="88">88</th><td><em>void</em> <a class="decl" href="../../accel/tcg/cpu-exec-common.c.html#cpu_reloading_memory_map" title='cpu_reloading_memory_map' data-ref="cpu_reloading_memory_map" id="cpu_reloading_memory_map">cpu_reloading_memory_map</a>(<em>void</em>);</td></tr>
<tr><th id="89">89</th><td><i class="doc">/**</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> * cpu_address_space_init:</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU to add this address space to</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> *<span class="command"> @as</span><span class="arg">:</span> address space to add</i></td></tr>
<tr><th id="93">93</th><td><i class="doc"> *<span class="command"> @asidx</span>: integer index of this address space</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> *</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> * Add the specified address space to the CPU's cpu_ases list.</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * The address space added with<span class="command"> @asidx</span> 0 is the one used for the</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> * convenience pointer cpu-&gt;as.</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> * The target-specific code which registers ASes is responsible</i></td></tr>
<tr><th id="99">99</th><td><i class="doc"> * for defining what semantics address space 0, 1, 2, etc have.</i></td></tr>
<tr><th id="100">100</th><td><i class="doc"> *</i></td></tr>
<tr><th id="101">101</th><td><i class="doc"> * Before the first call to this function, the caller must set</i></td></tr>
<tr><th id="102">102</th><td><i class="doc"> * cpu-&gt;num_ases to the total number of address spaces it needs</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> * to support.</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> *</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> * Note that with KVM only one address space is supported.</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> */</i></td></tr>
<tr><th id="107">107</th><td><em>void</em> <dfn class="decl" id="cpu_address_space_init" title='cpu_address_space_init' data-ref="cpu_address_space_init">cpu_address_space_init</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="79cpu" title='cpu' data-type='CPUState *' data-ref="79cpu">cpu</dfn>, <a class="typedef" href="../qemu/typedefs.h.html#AddressSpace" title='AddressSpace' data-type='struct AddressSpace' data-ref="AddressSpace">AddressSpace</a> *<dfn class="local col0 decl" id="80as" title='as' data-type='AddressSpace *' data-ref="80as">as</dfn>, <em>int</em> <dfn class="local col1 decl" id="81asidx" title='asidx' data-type='int' data-ref="81asidx">asidx</dfn>);</td></tr>
<tr><th id="108">108</th><td><u>#<span data-ppcond="87">endif</span></u></td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><u>#<span data-ppcond="110">if</span> !defined(<span class="macro" data-ref="_M/CONFIG_USER_ONLY">CONFIG_USER_ONLY</span>) &amp;&amp; defined(<a class="macro" href="../../config-host.h.html#66" data-ref="_M/CONFIG_TCG">CONFIG_TCG</a>)</u></td></tr>
<tr><th id="111">111</th><td><i>/* cputlb.c */</i></td></tr>
<tr><th id="112">112</th><td><i class="doc">/**</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * tlb_flush_page:</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU whose TLB should be flushed</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> *</i></td></tr>
<tr><th id="117">117</th><td><i class="doc"> * Flush one page from the TLB of the specified CPU, for all</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> */</i></td></tr>
<tr><th id="120">120</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page" title='tlb_flush_page' data-ref="tlb_flush_page">tlb_flush_page</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col2 decl" id="82cpu" title='cpu' data-type='CPUState *' data-ref="82cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col3 decl" id="83addr" title='addr' data-type='target_ulong' data-ref="83addr">addr</dfn>);</td></tr>
<tr><th id="121">121</th><td><i class="doc">/**</i></td></tr>
<tr><th id="122">122</th><td><i class="doc"> * tlb_flush_page_all_cpus:</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> *<span class="command"> @cpu</span>: src CPU of the flush</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> *</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> * Flush one page from the TLB of the specified CPU, for all</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="128">128</th><td><i class="doc"> */</i></td></tr>
<tr><th id="129">129</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page_all_cpus" title='tlb_flush_page_all_cpus' data-ref="tlb_flush_page_all_cpus">tlb_flush_page_all_cpus</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="84src" title='src' data-type='CPUState *' data-ref="84src">src</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col5 decl" id="85addr" title='addr' data-type='target_ulong' data-ref="85addr">addr</dfn>);</td></tr>
<tr><th id="130">130</th><td><i class="doc">/**</i></td></tr>
<tr><th id="131">131</th><td><i class="doc"> * tlb_flush_page_all_cpus_synced:</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> *<span class="command"> @cpu</span>: src CPU of the flush</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> *</i></td></tr>
<tr><th id="135">135</th><td><i class="doc"> * Flush one page from the TLB of the specified CPU, for all MMU</i></td></tr>
<tr><th id="136">136</th><td><i class="doc"> * indexes like tlb_flush_page_all_cpus except the source vCPUs work</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> * is scheduled as safe work meaning all flushes will be complete once</i></td></tr>
<tr><th id="138">138</th><td><i class="doc"> * the source vCPUs safe work is complete. This will depend on when</i></td></tr>
<tr><th id="139">139</th><td><i class="doc"> * the guests translation ends the TB.</i></td></tr>
<tr><th id="140">140</th><td><i class="doc"> */</i></td></tr>
<tr><th id="141">141</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page_all_cpus_synced" title='tlb_flush_page_all_cpus_synced' data-ref="tlb_flush_page_all_cpus_synced">tlb_flush_page_all_cpus_synced</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col6 decl" id="86src" title='src' data-type='CPUState *' data-ref="86src">src</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col7 decl" id="87addr" title='addr' data-type='target_ulong' data-ref="87addr">addr</dfn>);</td></tr>
<tr><th id="142">142</th><td><i class="doc">/**</i></td></tr>
<tr><th id="143">143</th><td><i class="doc"> * tlb_flush:</i></td></tr>
<tr><th id="144">144</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU whose TLB should be flushed</i></td></tr>
<tr><th id="145">145</th><td><i class="doc"> *</i></td></tr>
<tr><th id="146">146</th><td><i class="doc"> * Flush the entire TLB for the specified CPU. Most CPU architectures</i></td></tr>
<tr><th id="147">147</th><td><i class="doc"> * allow the implementation to drop entries from the TLB at any time</i></td></tr>
<tr><th id="148">148</th><td><i class="doc"> * so this is generally safe. If more selective flushing is required</i></td></tr>
<tr><th id="149">149</th><td><i class="doc"> * use one of the other functions for efficiency.</i></td></tr>
<tr><th id="150">150</th><td><i class="doc"> */</i></td></tr>
<tr><th id="151">151</th><td><em>void</em> <dfn class="decl" id="tlb_flush" title='tlb_flush' data-ref="tlb_flush">tlb_flush</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col8 decl" id="88cpu" title='cpu' data-type='CPUState *' data-ref="88cpu">cpu</dfn>);</td></tr>
<tr><th id="152">152</th><td><i class="doc">/**</i></td></tr>
<tr><th id="153">153</th><td><i class="doc"> * tlb_flush_all_cpus:</i></td></tr>
<tr><th id="154">154</th><td><i class="doc"> *<span class="command"> @cpu</span>: src CPU of the flush</i></td></tr>
<tr><th id="155">155</th><td><i class="doc"> */</i></td></tr>
<tr><th id="156">156</th><td><em>void</em> <dfn class="decl" id="tlb_flush_all_cpus" title='tlb_flush_all_cpus' data-ref="tlb_flush_all_cpus">tlb_flush_all_cpus</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="89src_cpu" title='src_cpu' data-type='CPUState *' data-ref="89src_cpu">src_cpu</dfn>);</td></tr>
<tr><th id="157">157</th><td><i class="doc">/**</i></td></tr>
<tr><th id="158">158</th><td><i class="doc"> * tlb_flush_all_cpus_synced:</i></td></tr>
<tr><th id="159">159</th><td><i class="doc"> *<span class="command"> @cpu</span>: src CPU of the flush</i></td></tr>
<tr><th id="160">160</th><td><i class="doc"> *</i></td></tr>
<tr><th id="161">161</th><td><i class="doc"> * Like tlb_flush_all_cpus except this except the source vCPUs work is</i></td></tr>
<tr><th id="162">162</th><td><i class="doc"> * scheduled as safe work meaning all flushes will be complete once</i></td></tr>
<tr><th id="163">163</th><td><i class="doc"> * the source vCPUs safe work is complete. This will depend on when</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> * the guests translation ends the TB.</i></td></tr>
<tr><th id="165">165</th><td><i class="doc"> */</i></td></tr>
<tr><th id="166">166</th><td><em>void</em> <dfn class="decl" id="tlb_flush_all_cpus_synced" title='tlb_flush_all_cpus_synced' data-ref="tlb_flush_all_cpus_synced">tlb_flush_all_cpus_synced</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col0 decl" id="90src_cpu" title='src_cpu' data-type='CPUState *' data-ref="90src_cpu">src_cpu</dfn>);</td></tr>
<tr><th id="167">167</th><td><i class="doc">/**</i></td></tr>
<tr><th id="168">168</th><td><i class="doc"> * tlb_flush_page_by_mmuidx:</i></td></tr>
<tr><th id="169">169</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU whose TLB should be flushed</i></td></tr>
<tr><th id="170">170</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="171">171</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="172">172</th><td><i class="doc"> *</i></td></tr>
<tr><th id="173">173</th><td><i class="doc"> * Flush one page from the TLB of the specified CPU, for the specified</i></td></tr>
<tr><th id="174">174</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="175">175</th><td><i class="doc"> */</i></td></tr>
<tr><th id="176">176</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page_by_mmuidx" title='tlb_flush_page_by_mmuidx' data-ref="tlb_flush_page_by_mmuidx">tlb_flush_page_by_mmuidx</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col1 decl" id="91cpu" title='cpu' data-type='CPUState *' data-ref="91cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col2 decl" id="92addr" title='addr' data-type='target_ulong' data-ref="92addr">addr</dfn>,</td></tr>
<tr><th id="177">177</th><td>                              <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col3 decl" id="93idxmap" title='idxmap' data-type='uint16_t' data-ref="93idxmap">idxmap</dfn>);</td></tr>
<tr><th id="178">178</th><td><i class="doc">/**</i></td></tr>
<tr><th id="179">179</th><td><i class="doc"> * tlb_flush_page_by_mmuidx_all_cpus:</i></td></tr>
<tr><th id="180">180</th><td><i class="doc"> *<span class="command"> @cpu</span>: Originating CPU of the flush</i></td></tr>
<tr><th id="181">181</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="182">182</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="183">183</th><td><i class="doc"> *</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> * Flush one page from the TLB of all CPUs, for the specified</i></td></tr>
<tr><th id="185">185</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> */</i></td></tr>
<tr><th id="187">187</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page_by_mmuidx_all_cpus" title='tlb_flush_page_by_mmuidx_all_cpus' data-ref="tlb_flush_page_by_mmuidx_all_cpus">tlb_flush_page_by_mmuidx_all_cpus</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="94cpu" title='cpu' data-type='CPUState *' data-ref="94cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col5 decl" id="95addr" title='addr' data-type='target_ulong' data-ref="95addr">addr</dfn>,</td></tr>
<tr><th id="188">188</th><td>                                       <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col6 decl" id="96idxmap" title='idxmap' data-type='uint16_t' data-ref="96idxmap">idxmap</dfn>);</td></tr>
<tr><th id="189">189</th><td><i class="doc">/**</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> * tlb_flush_page_by_mmuidx_all_cpus_synced:</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> *<span class="command"> @cpu</span>: Originating CPU of the flush</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> *<span class="command"> @addr</span>: virtual address of page to be flushed</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="194">194</th><td><i class="doc"> *</i></td></tr>
<tr><th id="195">195</th><td><i class="doc"> * Flush one page from the TLB of all CPUs, for the specified MMU</i></td></tr>
<tr><th id="196">196</th><td><i class="doc"> * indexes like tlb_flush_page_by_mmuidx_all_cpus except the source</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> * vCPUs work is scheduled as safe work meaning all flushes will be</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> * complete once  the source vCPUs safe work is complete. This will</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> * depend on when the guests translation ends the TB.</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> */</i></td></tr>
<tr><th id="201">201</th><td><em>void</em> <dfn class="decl" id="tlb_flush_page_by_mmuidx_all_cpus_synced" title='tlb_flush_page_by_mmuidx_all_cpus_synced' data-ref="tlb_flush_page_by_mmuidx_all_cpus_synced">tlb_flush_page_by_mmuidx_all_cpus_synced</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col7 decl" id="97cpu" title='cpu' data-type='CPUState *' data-ref="97cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col8 decl" id="98addr" title='addr' data-type='target_ulong' data-ref="98addr">addr</dfn>,</td></tr>
<tr><th id="202">202</th><td>                                              <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col9 decl" id="99idxmap" title='idxmap' data-type='uint16_t' data-ref="99idxmap">idxmap</dfn>);</td></tr>
<tr><th id="203">203</th><td><i class="doc">/**</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> * tlb_flush_by_mmuidx:</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU whose TLB should be flushed</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> *<span class="command"> @wait</span>: If true ensure synchronisation by exiting the cpu_loop</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="208">208</th><td><i class="doc"> *</i></td></tr>
<tr><th id="209">209</th><td><i class="doc"> * Flush all entries from the TLB of the specified CPU, for the specified</i></td></tr>
<tr><th id="210">210</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="211">211</th><td><i class="doc"> */</i></td></tr>
<tr><th id="212">212</th><td><em>void</em> <dfn class="decl" id="tlb_flush_by_mmuidx" title='tlb_flush_by_mmuidx' data-ref="tlb_flush_by_mmuidx">tlb_flush_by_mmuidx</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col0 decl" id="100cpu" title='cpu' data-type='CPUState *' data-ref="100cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col1 decl" id="101idxmap" title='idxmap' data-type='uint16_t' data-ref="101idxmap">idxmap</dfn>);</td></tr>
<tr><th id="213">213</th><td><i class="doc">/**</i></td></tr>
<tr><th id="214">214</th><td><i class="doc"> * tlb_flush_by_mmuidx_all_cpus:</i></td></tr>
<tr><th id="215">215</th><td><i class="doc"> *<span class="command"> @cpu</span>: Originating CPU of the flush</i></td></tr>
<tr><th id="216">216</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="217">217</th><td><i class="doc"> *</i></td></tr>
<tr><th id="218">218</th><td><i class="doc"> * Flush all entries from all TLBs of all CPUs, for the specified</i></td></tr>
<tr><th id="219">219</th><td><i class="doc"> * MMU indexes.</i></td></tr>
<tr><th id="220">220</th><td><i class="doc"> */</i></td></tr>
<tr><th id="221">221</th><td><em>void</em> <dfn class="decl" id="tlb_flush_by_mmuidx_all_cpus" title='tlb_flush_by_mmuidx_all_cpus' data-ref="tlb_flush_by_mmuidx_all_cpus">tlb_flush_by_mmuidx_all_cpus</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col2 decl" id="102cpu" title='cpu' data-type='CPUState *' data-ref="102cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col3 decl" id="103idxmap" title='idxmap' data-type='uint16_t' data-ref="103idxmap">idxmap</dfn>);</td></tr>
<tr><th id="222">222</th><td><i class="doc">/**</i></td></tr>
<tr><th id="223">223</th><td><i class="doc"> * tlb_flush_by_mmuidx_all_cpus_synced:</i></td></tr>
<tr><th id="224">224</th><td><i class="doc"> *<span class="command"> @cpu</span>: Originating CPU of the flush</i></td></tr>
<tr><th id="225">225</th><td><i class="doc"> *<span class="command"> @idxmap</span>: bitmap of MMU indexes to flush</i></td></tr>
<tr><th id="226">226</th><td><i class="doc"> *</i></td></tr>
<tr><th id="227">227</th><td><i class="doc"> * Flush all entries from all TLBs of all CPUs, for the specified</i></td></tr>
<tr><th id="228">228</th><td><i class="doc"> * MMU indexes like tlb_flush_by_mmuidx_all_cpus except except the source</i></td></tr>
<tr><th id="229">229</th><td><i class="doc"> * vCPUs work is scheduled as safe work meaning all flushes will be</i></td></tr>
<tr><th id="230">230</th><td><i class="doc"> * complete once  the source vCPUs safe work is complete. This will</i></td></tr>
<tr><th id="231">231</th><td><i class="doc"> * depend on when the guests translation ends the TB.</i></td></tr>
<tr><th id="232">232</th><td><i class="doc"> */</i></td></tr>
<tr><th id="233">233</th><td><em>void</em> <dfn class="decl" id="tlb_flush_by_mmuidx_all_cpus_synced" title='tlb_flush_by_mmuidx_all_cpus_synced' data-ref="tlb_flush_by_mmuidx_all_cpus_synced">tlb_flush_by_mmuidx_all_cpus_synced</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="104cpu" title='cpu' data-type='CPUState *' data-ref="104cpu">cpu</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col5 decl" id="105idxmap" title='idxmap' data-type='uint16_t' data-ref="105idxmap">idxmap</dfn>);</td></tr>
<tr><th id="234">234</th><td><i class="doc">/**</i></td></tr>
<tr><th id="235">235</th><td><i class="doc"> * tlb_set_page_with_attrs:</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> *<span class="command"> @cpu</span>: CPU to add this TLB entry for</i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> *<span class="command"> @vaddr</span>: virtual address of page to add entry for</i></td></tr>
<tr><th id="238">238</th><td><i class="doc"> *<span class="command"> @paddr</span>: physical address of the page</i></td></tr>
<tr><th id="239">239</th><td><i class="doc"> *<span class="command"> @attrs</span>: memory transaction attributes</i></td></tr>
<tr><th id="240">240</th><td><i class="doc"> *<span class="command"> @prot</span>: access permissions (PAGE_READ/PAGE_WRITE/PAGE_EXEC bits)</i></td></tr>
<tr><th id="241">241</th><td><i class="doc"> *<span class="command"> @mmu</span>_idx: MMU index to insert TLB entry for</i></td></tr>
<tr><th id="242">242</th><td><i class="doc"> *<span class="command"> @size</span>: size of the page in bytes</i></td></tr>
<tr><th id="243">243</th><td><i class="doc"> *</i></td></tr>
<tr><th id="244">244</th><td><i class="doc"> * Add an entry to this CPU's TLB (a mapping from virtual address</i></td></tr>
<tr><th id="245">245</th><td><i class="doc"> *<span class="command"> @vaddr</span> to physical address<span class="command"> @paddr</span>) with the specified memory</i></td></tr>
<tr><th id="246">246</th><td><i class="doc"> * transaction attributes. This is generally called by the target CPU</i></td></tr>
<tr><th id="247">247</th><td><i class="doc"> * specific code after it has been called through the tlb_fill()</i></td></tr>
<tr><th id="248">248</th><td><i class="doc"> * entry point and performed a successful page table walk to find</i></td></tr>
<tr><th id="249">249</th><td><i class="doc"> * the physical address and attributes for the virtual address</i></td></tr>
<tr><th id="250">250</th><td><i class="doc"> * which provoked the TLB miss.</i></td></tr>
<tr><th id="251">251</th><td><i class="doc"> *</i></td></tr>
<tr><th id="252">252</th><td><i class="doc"> * At most one entry for a given virtual address is permitted. Only a</i></td></tr>
<tr><th id="253">253</th><td><i class="doc"> * single TARGET_PAGE_SIZE region is mapped; the supplied<span class="command"> @size</span> is only</i></td></tr>
<tr><th id="254">254</th><td><i class="doc"> * used by tlb_flush_page.</i></td></tr>
<tr><th id="255">255</th><td><i class="doc"> */</i></td></tr>
<tr><th id="256">256</th><td><em>void</em> <dfn class="decl" id="tlb_set_page_with_attrs" title='tlb_set_page_with_attrs' data-ref="tlb_set_page_with_attrs">tlb_set_page_with_attrs</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col6 decl" id="106cpu" title='cpu' data-type='CPUState *' data-ref="106cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col7 decl" id="107vaddr" title='vaddr' data-type='target_ulong' data-ref="107vaddr">vaddr</dfn>,</td></tr>
<tr><th id="257">257</th><td>                             <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col8 decl" id="108paddr" title='paddr' data-type='hwaddr' data-ref="108paddr">paddr</dfn>, <a class="typedef" href="memattrs.h.html#MemTxAttrs" title='MemTxAttrs' data-type='struct MemTxAttrs' data-ref="MemTxAttrs">MemTxAttrs</a> <dfn class="local col9 decl" id="109attrs" title='attrs' data-type='MemTxAttrs' data-ref="109attrs">attrs</dfn>,</td></tr>
<tr><th id="258">258</th><td>                             <em>int</em> <dfn class="local col0 decl" id="110prot" title='prot' data-type='int' data-ref="110prot">prot</dfn>, <em>int</em> <dfn class="local col1 decl" id="111mmu_idx" title='mmu_idx' data-type='int' data-ref="111mmu_idx">mmu_idx</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col2 decl" id="112size" title='size' data-type='target_ulong' data-ref="112size">size</dfn>);</td></tr>
<tr><th id="259">259</th><td><i>/* tlb_set_page:</i></td></tr>
<tr><th id="260">260</th><td><i> *</i></td></tr>
<tr><th id="261">261</th><td><i> * This function is equivalent to calling tlb_set_page_with_attrs()</i></td></tr>
<tr><th id="262">262</th><td><i> * with an @attrs argument of MEMTXATTRS_UNSPECIFIED. It's provided</i></td></tr>
<tr><th id="263">263</th><td><i> * as a convenience for CPUs which don't use memory transaction attributes.</i></td></tr>
<tr><th id="264">264</th><td><i> */</i></td></tr>
<tr><th id="265">265</th><td><em>void</em> <dfn class="decl" id="tlb_set_page" title='tlb_set_page' data-ref="tlb_set_page">tlb_set_page</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col3 decl" id="113cpu" title='cpu' data-type='CPUState *' data-ref="113cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col4 decl" id="114vaddr" title='vaddr' data-type='target_ulong' data-ref="114vaddr">vaddr</dfn>,</td></tr>
<tr><th id="266">266</th><td>                  <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col5 decl" id="115paddr" title='paddr' data-type='hwaddr' data-ref="115paddr">paddr</dfn>, <em>int</em> <dfn class="local col6 decl" id="116prot" title='prot' data-type='int' data-ref="116prot">prot</dfn>,</td></tr>
<tr><th id="267">267</th><td>                  <em>int</em> <dfn class="local col7 decl" id="117mmu_idx" title='mmu_idx' data-type='int' data-ref="117mmu_idx">mmu_idx</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col8 decl" id="118size" title='size' data-type='target_ulong' data-ref="118size">size</dfn>);</td></tr>
<tr><th id="268">268</th><td><em>void</em> <dfn class="decl" id="tb_invalidate_phys_addr" title='tb_invalidate_phys_addr' data-ref="tb_invalidate_phys_addr">tb_invalidate_phys_addr</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#AddressSpace" title='AddressSpace' data-type='struct AddressSpace' data-ref="AddressSpace">AddressSpace</a> *<dfn class="local col9 decl" id="119as" title='as' data-type='AddressSpace *' data-ref="119as">as</dfn>, <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col0 decl" id="120addr" title='addr' data-type='hwaddr' data-ref="120addr">addr</dfn>);</td></tr>
<tr><th id="269">269</th><td><em>void</em> <dfn class="decl" id="probe_write" title='probe_write' data-ref="probe_write">probe_write</dfn>(<a class="macro" href="../../target/i386/cpu.h.html#51" title="struct CPUX86State" data-ref="_M/CPUArchState">CPUArchState</a> *<dfn class="local col1 decl" id="121env" title='env' data-type='struct CPUX86State *' data-ref="121env">env</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col2 decl" id="122addr" title='addr' data-type='target_ulong' data-ref="122addr">addr</dfn>, <em>int</em> <dfn class="local col3 decl" id="123mmu_idx" title='mmu_idx' data-type='int' data-ref="123mmu_idx">mmu_idx</dfn>,</td></tr>
<tr><th id="270">270</th><td>                 <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col4 decl" id="124retaddr" title='retaddr' data-type='uintptr_t' data-ref="124retaddr">retaddr</dfn>);</td></tr>
<tr><th id="271">271</th><td><u>#<span data-ppcond="110">else</span></u></td></tr>
<tr><th id="272">272</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page(CPUState *cpu, target_ulong addr)</td></tr>
<tr><th id="273">273</th><td>{</td></tr>
<tr><th id="274">274</th><td>}</td></tr>
<tr><th id="275">275</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page_all_cpus(CPUState *src, target_ulong addr)</td></tr>
<tr><th id="276">276</th><td>{</td></tr>
<tr><th id="277">277</th><td>}</td></tr>
<tr><th id="278">278</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page_all_cpus_synced(CPUState *src,</td></tr>
<tr><th id="279">279</th><td>                                                  target_ulong addr)</td></tr>
<tr><th id="280">280</th><td>{</td></tr>
<tr><th id="281">281</th><td>}</td></tr>
<tr><th id="282">282</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush(CPUState *cpu)</td></tr>
<tr><th id="283">283</th><td>{</td></tr>
<tr><th id="284">284</th><td>}</td></tr>
<tr><th id="285">285</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_all_cpus(CPUState *src_cpu)</td></tr>
<tr><th id="286">286</th><td>{</td></tr>
<tr><th id="287">287</th><td>}</td></tr>
<tr><th id="288">288</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_all_cpus_synced(CPUState *src_cpu)</td></tr>
<tr><th id="289">289</th><td>{</td></tr>
<tr><th id="290">290</th><td>}</td></tr>
<tr><th id="291">291</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page_by_mmuidx(CPUState *cpu,</td></tr>
<tr><th id="292">292</th><td>                                            target_ulong addr, uint16_t idxmap)</td></tr>
<tr><th id="293">293</th><td>{</td></tr>
<tr><th id="294">294</th><td>}</td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_by_mmuidx(CPUState *cpu, uint16_t idxmap)</td></tr>
<tr><th id="297">297</th><td>{</td></tr>
<tr><th id="298">298</th><td>}</td></tr>
<tr><th id="299">299</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page_by_mmuidx_all_cpus(CPUState *cpu,</td></tr>
<tr><th id="300">300</th><td>                                                     target_ulong addr,</td></tr>
<tr><th id="301">301</th><td>                                                     uint16_t idxmap)</td></tr>
<tr><th id="302">302</th><td>{</td></tr>
<tr><th id="303">303</th><td>}</td></tr>
<tr><th id="304">304</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_page_by_mmuidx_all_cpus_synced(CPUState *cpu,</td></tr>
<tr><th id="305">305</th><td>                                                            target_ulong addr,</td></tr>
<tr><th id="306">306</th><td>                                                            uint16_t idxmap)</td></tr>
<tr><th id="307">307</th><td>{</td></tr>
<tr><th id="308">308</th><td>}</td></tr>
<tr><th id="309">309</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_by_mmuidx_all_cpus(CPUState *cpu, uint16_t idxmap)</td></tr>
<tr><th id="310">310</th><td>{</td></tr>
<tr><th id="311">311</th><td>}</td></tr>
<tr><th id="312">312</th><td><em>static</em> <b>inline</b> <em>void</em> tlb_flush_by_mmuidx_all_cpus_synced(CPUState *cpu,</td></tr>
<tr><th id="313">313</th><td>                                                       uint16_t idxmap)</td></tr>
<tr><th id="314">314</th><td>{</td></tr>
<tr><th id="315">315</th><td>}</td></tr>
<tr><th id="316">316</th><td><em>static</em> <b>inline</b> <em>void</em> tb_invalidate_phys_addr(AddressSpace *as, hwaddr addr)</td></tr>
<tr><th id="317">317</th><td>{</td></tr>
<tr><th id="318">318</th><td>}</td></tr>
<tr><th id="319">319</th><td><u>#<span data-ppcond="110">endif</span></u></td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><u>#define <dfn class="macro" id="_M/CODE_GEN_ALIGN" data-ref="_M/CODE_GEN_ALIGN">CODE_GEN_ALIGN</dfn>           16 /* must be &gt;= of the size of a icache line */</u></td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td><i>/* Estimated block size for TB allocation.  */</i></td></tr>
<tr><th id="324">324</th><td><i>/* ??? The following is based on a 2015 survey of x86_64 host output.</i></td></tr>
<tr><th id="325">325</th><td><i>   Better would seem to be some sort of dynamically sized TB array,</i></td></tr>
<tr><th id="326">326</th><td><i>   adapting to the block sizes actually being produced.  */</i></td></tr>
<tr><th id="327">327</th><td><u>#<span data-ppcond="327">if</span> defined(<a class="macro" href="../../x86_64-softmmu/config-target.h.html#7" data-ref="_M/CONFIG_SOFTMMU">CONFIG_SOFTMMU</a>)</u></td></tr>
<tr><th id="328">328</th><td><u>#define <dfn class="macro" id="_M/CODE_GEN_AVG_BLOCK_SIZE" data-ref="_M/CODE_GEN_AVG_BLOCK_SIZE">CODE_GEN_AVG_BLOCK_SIZE</dfn> 400</u></td></tr>
<tr><th id="329">329</th><td><u>#<span data-ppcond="327">else</span></u></td></tr>
<tr><th id="330">330</th><td><u>#define CODE_GEN_AVG_BLOCK_SIZE 150</u></td></tr>
<tr><th id="331">331</th><td><u>#<span data-ppcond="327">endif</span></u></td></tr>
<tr><th id="332">332</th><td></td></tr>
<tr><th id="333">333</th><td><u>#<span data-ppcond="333">if</span> defined(<span class="macro" data-ref="_M/_ARCH_PPC">_ARCH_PPC</span>) \</u></td></tr>
<tr><th id="334">334</th><td><u>    || defined(<span class="macro" data-ref="_M/__x86_64__">__x86_64__</span>) || defined(<span class="macro" data-ref="_M/__i386__">__i386__</span>) \</u></td></tr>
<tr><th id="335">335</th><td><u>    || defined(<span class="macro" data-ref="_M/__sparc__">__sparc__</span>) || defined(<span class="macro" data-ref="_M/__aarch64__">__aarch64__</span>) \</u></td></tr>
<tr><th id="336">336</th><td><u>    || defined(<span class="macro" data-ref="_M/__s390x__">__s390x__</span>) || defined(<span class="macro" data-ref="_M/__mips__">__mips__</span>) \</u></td></tr>
<tr><th id="337">337</th><td><u>    || defined(<span class="macro" data-ref="_M/CONFIG_TCG_INTERPRETER">CONFIG_TCG_INTERPRETER</span>)</u></td></tr>
<tr><th id="338">338</th><td><i>/* NOTE: Direct jump patching must be atomic to be thread-safe. */</i></td></tr>
<tr><th id="339">339</th><td><u>#define <dfn class="macro" id="_M/USE_DIRECT_JUMP" data-ref="_M/USE_DIRECT_JUMP">USE_DIRECT_JUMP</dfn></u></td></tr>
<tr><th id="340">340</th><td><u>#<span data-ppcond="333">endif</span></u></td></tr>
<tr><th id="341">341</th><td></td></tr>
<tr><th id="342">342</th><td><b>struct</b> <dfn class="type def" id="TranslationBlock" title='TranslationBlock' data-ref="TranslationBlock">TranslationBlock</dfn> {</td></tr>
<tr><th id="343">343</th><td>    <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="decl" id="TranslationBlock::pc" title='TranslationBlock::pc' data-ref="TranslationBlock::pc">pc</dfn>;   <i>/* simulated PC corresponding to this block (EIP + CS base) */</i></td></tr>
<tr><th id="344">344</th><td>    <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="decl" id="TranslationBlock::cs_base" title='TranslationBlock::cs_base' data-ref="TranslationBlock::cs_base">cs_base</dfn>; <i>/* CS base for this block */</i></td></tr>
<tr><th id="345">345</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="TranslationBlock::flags" title='TranslationBlock::flags' data-ref="TranslationBlock::flags">flags</dfn>; <i>/* flags defining in which context the code was generated */</i></td></tr>
<tr><th id="346">346</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="TranslationBlock::size" title='TranslationBlock::size' data-ref="TranslationBlock::size">size</dfn>;      <i>/* size of target code for this block (1 &lt;=</i></td></tr>
<tr><th id="347">347</th><td><i>                           size &lt;= TARGET_PAGE_SIZE) */</i></td></tr>
<tr><th id="348">348</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="TranslationBlock::icount" title='TranslationBlock::icount' data-ref="TranslationBlock::icount">icount</dfn>;</td></tr>
<tr><th id="349">349</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="TranslationBlock::cflags" title='TranslationBlock::cflags' data-ref="TranslationBlock::cflags">cflags</dfn>;    <i>/* compile flags */</i></td></tr>
<tr><th id="350">350</th><td><u>#define <dfn class="macro" id="_M/CF_COUNT_MASK" data-ref="_M/CF_COUNT_MASK">CF_COUNT_MASK</dfn>  0x7fff</u></td></tr>
<tr><th id="351">351</th><td><u>#define <dfn class="macro" id="_M/CF_LAST_IO" data-ref="_M/CF_LAST_IO">CF_LAST_IO</dfn>     0x8000 /* Last insn may be an IO access.  */</u></td></tr>
<tr><th id="352">352</th><td><u>#define <dfn class="macro" id="_M/CF_NOCACHE" data-ref="_M/CF_NOCACHE">CF_NOCACHE</dfn>     0x10000 /* To be freed after execution */</u></td></tr>
<tr><th id="353">353</th><td><u>#define <dfn class="macro" id="_M/CF_USE_ICOUNT" data-ref="_M/CF_USE_ICOUNT">CF_USE_ICOUNT</dfn>  0x20000</u></td></tr>
<tr><th id="354">354</th><td><u>#define <dfn class="macro" id="_M/CF_IGNORE_ICOUNT" data-ref="_M/CF_IGNORE_ICOUNT">CF_IGNORE_ICOUNT</dfn> 0x40000 /* Do not generate icount code */</u></td></tr>
<tr><th id="355">355</th><td></td></tr>
<tr><th id="356">356</th><td>    <i>/* Per-vCPU dynamic tracing state used to generate this TB */</i></td></tr>
<tr><th id="357">357</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl" id="TranslationBlock::trace_vcpu_dstate" title='TranslationBlock::trace_vcpu_dstate' data-ref="TranslationBlock::trace_vcpu_dstate">trace_vcpu_dstate</dfn>;</td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="TranslationBlock::invalid" title='TranslationBlock::invalid' data-ref="TranslationBlock::invalid">invalid</dfn>;</td></tr>
<tr><th id="360">360</th><td></td></tr>
<tr><th id="361">361</th><td>    <em>void</em> *<dfn class="decl" id="TranslationBlock::tc_ptr" title='TranslationBlock::tc_ptr' data-ref="TranslationBlock::tc_ptr">tc_ptr</dfn>;    <i>/* pointer to the translated code */</i></td></tr>
<tr><th id="362">362</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> *<dfn class="decl" id="TranslationBlock::tc_search" title='TranslationBlock::tc_search' data-ref="TranslationBlock::tc_search">tc_search</dfn>;  <i>/* pointer to search data */</i></td></tr>
<tr><th id="363">363</th><td>    <i>/* original tb when cflags has CF_NOCACHE */</i></td></tr>
<tr><th id="364">364</th><td>    <b>struct</b> <a class="type" href="#TranslationBlock" title='TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="decl" id="TranslationBlock::orig_tb" title='TranslationBlock::orig_tb' data-ref="TranslationBlock::orig_tb">orig_tb</dfn>;</td></tr>
<tr><th id="365">365</th><td>    <i>/* first and second physical page containing code. The lower bit</i></td></tr>
<tr><th id="366">366</th><td><i>       of the pointer tells the index in page_next[] */</i></td></tr>
<tr><th id="367">367</th><td>    <b>struct</b> <a class="type" href="#TranslationBlock" title='TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="decl" id="TranslationBlock::page_next" title='TranslationBlock::page_next' data-ref="TranslationBlock::page_next">page_next</dfn>[<var>2</var>];</td></tr>
<tr><th id="368">368</th><td>    <a class="typedef" href="#tb_page_addr_t" title='tb_page_addr_t' data-type='ram_addr_t' data-ref="tb_page_addr_t">tb_page_addr_t</a> <dfn class="decl" id="TranslationBlock::page_addr" title='TranslationBlock::page_addr' data-ref="TranslationBlock::page_addr">page_addr</dfn>[<var>2</var>];</td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td>    <i>/* The following data are used to directly call another TB from</i></td></tr>
<tr><th id="371">371</th><td><i>     * the code of this one. This can be done either by emitting direct or</i></td></tr>
<tr><th id="372">372</th><td><i>     * indirect native jump instructions. These jumps are reset so that the TB</i></td></tr>
<tr><th id="373">373</th><td><i>     * just continue its execution. The TB can be linked to another one by</i></td></tr>
<tr><th id="374">374</th><td><i>     * setting one of the jump targets (or patching the jump instruction). Only</i></td></tr>
<tr><th id="375">375</th><td><i>     * two of such jumps are supported.</i></td></tr>
<tr><th id="376">376</th><td><i>     */</i></td></tr>
<tr><th id="377">377</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="TranslationBlock::jmp_reset_offset" title='TranslationBlock::jmp_reset_offset' data-ref="TranslationBlock::jmp_reset_offset">jmp_reset_offset</dfn>[<var>2</var>]; <i>/* offset of original jump target */</i></td></tr>
<tr><th id="378">378</th><td><u>#define <dfn class="macro" id="_M/TB_JMP_RESET_OFFSET_INVALID" data-ref="_M/TB_JMP_RESET_OFFSET_INVALID">TB_JMP_RESET_OFFSET_INVALID</dfn> 0xffff /* indicates no jump generated */</u></td></tr>
<tr><th id="379">379</th><td><u>#<span data-ppcond="379">ifdef</span> <a class="macro" href="#339" data-ref="_M/USE_DIRECT_JUMP">USE_DIRECT_JUMP</a></u></td></tr>
<tr><th id="380">380</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="decl" id="TranslationBlock::jmp_insn_offset" title='TranslationBlock::jmp_insn_offset' data-ref="TranslationBlock::jmp_insn_offset">jmp_insn_offset</dfn>[<var>2</var>]; <i>/* offset of native jump instruction */</i></td></tr>
<tr><th id="381">381</th><td><u>#<span data-ppcond="379">else</span></u></td></tr>
<tr><th id="382">382</th><td>    uintptr_t jmp_target_addr[<var>2</var>]; <i>/* target address for indirect jump */</i></td></tr>
<tr><th id="383">383</th><td><u>#<span data-ppcond="379">endif</span></u></td></tr>
<tr><th id="384">384</th><td>    <i>/* Each TB has an assosiated circular list of TBs jumping to this one.</i></td></tr>
<tr><th id="385">385</th><td><i>     * jmp_list_first points to the first TB jumping to this one.</i></td></tr>
<tr><th id="386">386</th><td><i>     * jmp_list_next is used to point to the next TB in a list.</i></td></tr>
<tr><th id="387">387</th><td><i>     * Since each TB can have two jumps, it can participate in two lists.</i></td></tr>
<tr><th id="388">388</th><td><i>     * jmp_list_first and jmp_list_next are 4-byte aligned pointers to a</i></td></tr>
<tr><th id="389">389</th><td><i>     * TranslationBlock structure, but the two least significant bits of</i></td></tr>
<tr><th id="390">390</th><td><i>     * them are used to encode which data field of the pointed TB should</i></td></tr>
<tr><th id="391">391</th><td><i>     * be used to traverse the list further from that TB:</i></td></tr>
<tr><th id="392">392</th><td><i>     * 0 =&gt; jmp_list_next[0], 1 =&gt; jmp_list_next[1], 2 =&gt; jmp_list_first.</i></td></tr>
<tr><th id="393">393</th><td><i>     * In other words, 0/1 tells which jump is used in the pointed TB,</i></td></tr>
<tr><th id="394">394</th><td><i>     * and 2 means that this is a pointer back to the target TB of this list.</i></td></tr>
<tr><th id="395">395</th><td><i>     */</i></td></tr>
<tr><th id="396">396</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="decl" id="TranslationBlock::jmp_list_next" title='TranslationBlock::jmp_list_next' data-ref="TranslationBlock::jmp_list_next">jmp_list_next</dfn>[<var>2</var>];</td></tr>
<tr><th id="397">397</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="decl" id="TranslationBlock::jmp_list_first" title='TranslationBlock::jmp_list_first' data-ref="TranslationBlock::jmp_list_first">jmp_list_first</dfn>;</td></tr>
<tr><th id="398">398</th><td>};</td></tr>
<tr><th id="399">399</th><td></td></tr>
<tr><th id="400">400</th><td><em>void</em> <dfn class="decl" id="tb_free" title='tb_free' data-ref="tb_free">tb_free</dfn>(<a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col5 decl" id="125tb" title='tb' data-type='TranslationBlock *' data-ref="125tb">tb</dfn>);</td></tr>
<tr><th id="401">401</th><td><em>void</em> <dfn class="decl" id="tb_flush" title='tb_flush' data-ref="tb_flush">tb_flush</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col6 decl" id="126cpu" title='cpu' data-type='CPUState *' data-ref="126cpu">cpu</dfn>);</td></tr>
<tr><th id="402">402</th><td><em>void</em> <dfn class="decl" id="tb_phys_invalidate" title='tb_phys_invalidate' data-ref="tb_phys_invalidate">tb_phys_invalidate</dfn>(<a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col7 decl" id="127tb" title='tb' data-type='TranslationBlock *' data-ref="127tb">tb</dfn>, <a class="typedef" href="#tb_page_addr_t" title='tb_page_addr_t' data-type='ram_addr_t' data-ref="tb_page_addr_t">tb_page_addr_t</a> <dfn class="local col8 decl" id="128page_addr" title='page_addr' data-type='tb_page_addr_t' data-ref="128page_addr">page_addr</dfn>);</td></tr>
<tr><th id="403">403</th><td><a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="decl" id="tb_htable_lookup" title='tb_htable_lookup' data-ref="tb_htable_lookup">tb_htable_lookup</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="129cpu" title='cpu' data-type='CPUState *' data-ref="129cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col0 decl" id="130pc" title='pc' data-type='target_ulong' data-ref="130pc">pc</dfn>,</td></tr>
<tr><th id="404">404</th><td>                                   <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col1 decl" id="131cs_base" title='cs_base' data-type='target_ulong' data-ref="131cs_base">cs_base</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="local col2 decl" id="132flags" title='flags' data-type='uint32_t' data-ref="132flags">flags</dfn>);</td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td><u>#<span data-ppcond="406">if</span> defined(<a class="macro" href="#339" data-ref="_M/USE_DIRECT_JUMP">USE_DIRECT_JUMP</a>)</u></td></tr>
<tr><th id="407">407</th><td></td></tr>
<tr><th id="408">408</th><td><u>#<span data-ppcond="408">if</span> defined(<span class="macro" data-ref="_M/CONFIG_TCG_INTERPRETER">CONFIG_TCG_INTERPRETER</span>)</u></td></tr>
<tr><th id="409">409</th><td><em>static</em> <b>inline</b> <em>void</em> tb_set_jmp_target1(uintptr_t jmp_addr, uintptr_t addr)</td></tr>
<tr><th id="410">410</th><td>{</td></tr>
<tr><th id="411">411</th><td>    <i>/* patch the branch destination */</i></td></tr>
<tr><th id="412">412</th><td>    atomic_set((int32_t *)jmp_addr, addr - (jmp_addr + <var>4</var>));</td></tr>
<tr><th id="413">413</th><td>    <i>/* no need to flush icache explicitly */</i></td></tr>
<tr><th id="414">414</th><td>}</td></tr>
<tr><th id="415">415</th><td><u>#<span data-ppcond="408">elif</span> defined(<span class="macro" data-ref="_M/_ARCH_PPC">_ARCH_PPC</span>)</u></td></tr>
<tr><th id="416">416</th><td><em>void</em> ppc_tb_set_jmp_target(uintptr_t jmp_addr, uintptr_t addr);</td></tr>
<tr><th id="417">417</th><td><u>#define tb_set_jmp_target1 ppc_tb_set_jmp_target</u></td></tr>
<tr><th id="418">418</th><td><u>#<span data-ppcond="408">elif</span> defined(<span class="macro" data-ref="_M/__i386__">__i386__</span>) || defined(<span class="macro" data-ref="_M/__x86_64__">__x86_64__</span>)</u></td></tr>
<tr><th id="419">419</th><td><em>static</em> <b>inline</b> <em>void</em> <dfn class="decl def" id="tb_set_jmp_target1" title='tb_set_jmp_target1' data-ref="tb_set_jmp_target1">tb_set_jmp_target1</dfn>(<a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col3 decl" id="133jmp_addr" title='jmp_addr' data-type='uintptr_t' data-ref="133jmp_addr">jmp_addr</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col4 decl" id="134addr" title='addr' data-type='uintptr_t' data-ref="134addr">addr</dfn>)</td></tr>
<tr><th id="420">420</th><td>{</td></tr>
<tr><th id="421">421</th><td>    <i>/* patch the branch destination */</i></td></tr>
<tr><th id="422">422</th><td>    <a class="macro" href="../qemu/atomic.h.html#132" title="do { _Static_assert(!(sizeof(*(int32_t *)jmp_addr) &gt; 8), &quot;not expecting: &quot; &quot;sizeof(*(int32_t *)jmp_addr) &gt; ATOMIC_REG_SIZE&quot;); __atomic_store_n((int32_t *)jmp_addr, addr - (jmp_addr + 4), 0); } while(0)" data-ref="_M/atomic_set">atomic_set</a>((<a class="typedef" href="../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> *)<a class="local col3 ref" href="#133jmp_addr" title='jmp_addr' data-ref="133jmp_addr">jmp_addr</a>, <a class="local col4 ref" href="#134addr" title='addr' data-ref="134addr">addr</a> - (<a class="local col3 ref" href="#133jmp_addr" title='jmp_addr' data-ref="133jmp_addr">jmp_addr</a> + <var>4</var>));</td></tr>
<tr><th id="423">423</th><td>    <i>/* no need to flush icache explicitly */</i></td></tr>
<tr><th id="424">424</th><td>}</td></tr>
<tr><th id="425">425</th><td><u>#<span data-ppcond="408">elif</span> defined(__s390x__)</u></td></tr>
<tr><th id="426">426</th><td><em>static</em> <b>inline</b> <em>void</em> tb_set_jmp_target1(uintptr_t jmp_addr, uintptr_t addr)</td></tr>
<tr><th id="427">427</th><td>{</td></tr>
<tr><th id="428">428</th><td>    <i>/* patch the branch destination */</i></td></tr>
<tr><th id="429">429</th><td>    intptr_t disp = addr - (jmp_addr - <var>2</var>);</td></tr>
<tr><th id="430">430</th><td>    atomic_set((int32_t *)jmp_addr, disp / <var>2</var>);</td></tr>
<tr><th id="431">431</th><td>    <i>/* no need to flush icache explicitly */</i></td></tr>
<tr><th id="432">432</th><td>}</td></tr>
<tr><th id="433">433</th><td><u>#elif defined(__aarch64__)</u></td></tr>
<tr><th id="434">434</th><td><em>void</em> aarch64_tb_set_jmp_target(uintptr_t jmp_addr, uintptr_t addr);</td></tr>
<tr><th id="435">435</th><td><u>#define tb_set_jmp_target1 aarch64_tb_set_jmp_target</u></td></tr>
<tr><th id="436">436</th><td><u>#elif defined(__sparc__) || defined(__mips__)</u></td></tr>
<tr><th id="437">437</th><td><em>void</em> tb_set_jmp_target1(uintptr_t jmp_addr, uintptr_t addr);</td></tr>
<tr><th id="438">438</th><td><u>#else</u></td></tr>
<tr><th id="439">439</th><td><u>#error tb_set_jmp_target1 is missing</u></td></tr>
<tr><th id="440">440</th><td><u>#<span data-ppcond="408">endif</span></u></td></tr>
<tr><th id="441">441</th><td></td></tr>
<tr><th id="442">442</th><td><em>static</em> <b>inline</b> <em>void</em> <dfn class="decl def" id="tb_set_jmp_target" title='tb_set_jmp_target' data-ref="tb_set_jmp_target">tb_set_jmp_target</dfn>(<a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col5 decl" id="135tb" title='tb' data-type='TranslationBlock *' data-ref="135tb">tb</dfn>,</td></tr>
<tr><th id="443">443</th><td>                                     <em>int</em> <dfn class="local col6 decl" id="136n" title='n' data-type='int' data-ref="136n">n</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col7 decl" id="137addr" title='addr' data-type='uintptr_t' data-ref="137addr">addr</dfn>)</td></tr>
<tr><th id="444">444</th><td>{</td></tr>
<tr><th id="445">445</th><td>    <a class="typedef" href="../../../include/stdint.h.html#uint16_t" title='uint16_t' data-type='unsigned short' data-ref="uint16_t">uint16_t</a> <dfn class="local col8 decl" id="138offset" title='offset' data-type='uint16_t' data-ref="138offset">offset</dfn> = <a class="local col5 ref" href="#135tb" title='tb' data-ref="135tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_insn_offset" title='TranslationBlock::jmp_insn_offset' data-ref="TranslationBlock::jmp_insn_offset">jmp_insn_offset</a>[<a class="local col6 ref" href="#136n" title='n' data-ref="136n">n</a>];</td></tr>
<tr><th id="446">446</th><td>    <a class="ref" href="#tb_set_jmp_target1" title='tb_set_jmp_target1' data-ref="tb_set_jmp_target1">tb_set_jmp_target1</a>((<a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a>)(<a class="local col5 ref" href="#135tb" title='tb' data-ref="135tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::tc_ptr" title='TranslationBlock::tc_ptr' data-ref="TranslationBlock::tc_ptr">tc_ptr</a> + <a class="local col8 ref" href="#138offset" title='offset' data-ref="138offset">offset</a>), <a class="local col7 ref" href="#137addr" title='addr' data-ref="137addr">addr</a>);</td></tr>
<tr><th id="447">447</th><td>}</td></tr>
<tr><th id="448">448</th><td></td></tr>
<tr><th id="449">449</th><td><u>#<span data-ppcond="406">else</span></u></td></tr>
<tr><th id="450">450</th><td></td></tr>
<tr><th id="451">451</th><td><i>/* set the jump target */</i></td></tr>
<tr><th id="452">452</th><td><em>static</em> <b>inline</b> <em>void</em> tb_set_jmp_target(TranslationBlock *tb,</td></tr>
<tr><th id="453">453</th><td>                                     <em>int</em> n, uintptr_t addr)</td></tr>
<tr><th id="454">454</th><td>{</td></tr>
<tr><th id="455">455</th><td>    tb-&gt;jmp_target_addr[n] = addr;</td></tr>
<tr><th id="456">456</th><td>}</td></tr>
<tr><th id="457">457</th><td></td></tr>
<tr><th id="458">458</th><td><u>#<span data-ppcond="406">endif</span></u></td></tr>
<tr><th id="459">459</th><td></td></tr>
<tr><th id="460">460</th><td><i>/* Called with tb_lock held.  */</i></td></tr>
<tr><th id="461">461</th><td><em>static</em> <b>inline</b> <em>void</em> <dfn class="decl def" id="tb_add_jump" title='tb_add_jump' data-ref="tb_add_jump">tb_add_jump</dfn>(<a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col9 decl" id="139tb" title='tb' data-type='TranslationBlock *' data-ref="139tb">tb</dfn>, <em>int</em> <dfn class="local col0 decl" id="140n" title='n' data-type='int' data-ref="140n">n</dfn>,</td></tr>
<tr><th id="462">462</th><td>                               <a class="typedef" href="tb-context.h.html#TranslationBlock" title='TranslationBlock' data-type='struct TranslationBlock' data-ref="TranslationBlock">TranslationBlock</a> *<dfn class="local col1 decl" id="141tb_next" title='tb_next' data-type='TranslationBlock *' data-ref="141tb_next">tb_next</dfn>)</td></tr>
<tr><th id="463">463</th><td>{</td></tr>
<tr><th id="464">464</th><td>    <a class="macro" href="../../../include/assert.h.html#88" title="((n &lt; ((sizeof(tb-&gt;jmp_list_next) / sizeof((tb-&gt;jmp_list_next)[0])) + (sizeof(struct { int:(!(!__builtin_types_compatible_p(typeof(tb-&gt;jmp_list_next), typeof(&amp;(tb-&gt;jmp_list_next)[0])))) ? -1 : 1; }) - sizeof(struct { int:(!(!__builtin_types_compatible_p(typeof(tb-&gt;jmp_list_next), typeof(&amp;(tb-&gt;jmp_list_next)[0])))) ? -1 : 1; })))) ? (void) (0) : __assert_fail (&quot;n &lt; ARRAY_SIZE(tb-&gt;jmp_list_next)&quot;, &quot;/home/jon/workspace/qemu/include/exec/exec-all.h&quot;, 464, __PRETTY_FUNCTION__))" data-ref="_M/assert">assert</a>(<a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a> &lt; <a class="macro" href="../qemu/osdep.h.html#208" title="((sizeof(tb-&gt;jmp_list_next) / sizeof((tb-&gt;jmp_list_next)[0])) + (sizeof(struct { int:(!(!__builtin_types_compatible_p(typeof(tb-&gt;jmp_list_next), typeof(&amp;(tb-&gt;jmp_list_next)[0])))) ? -1 : 1; }) - sizeof(struct { int:(!(!__builtin_types_compatible_p(typeof(tb-&gt;jmp_list_next), typeof(&amp;(tb-&gt;jmp_list_next)[0])))) ? -1 : 1; })))" data-ref="_M/ARRAY_SIZE">ARRAY_SIZE</a>(<a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_list_next" title='TranslationBlock::jmp_list_next' data-ref="TranslationBlock::jmp_list_next">jmp_list_next</a>));</td></tr>
<tr><th id="465">465</th><td>    <b>if</b> (<a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_list_next" title='TranslationBlock::jmp_list_next' data-ref="TranslationBlock::jmp_list_next">jmp_list_next</a>[<a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a>]) {</td></tr>
<tr><th id="466">466</th><td>        <i>/* Another thread has already done this while we were</i></td></tr>
<tr><th id="467">467</th><td><i>         * outside of the lock; nothing to do in this case */</i></td></tr>
<tr><th id="468">468</th><td>        <b>return</b>;</td></tr>
<tr><th id="469">469</th><td>    }</td></tr>
<tr><th id="470">470</th><td>    <a class="macro" href="../qemu/log.h.html#105" title="do { if (__builtin_expect(!!(qemu_loglevel_mask((1 &lt;&lt; 5))), 0) &amp;&amp; qemu_log_in_addr_range(tb-&gt;pc)) { qemu_log(&quot;Linking TBs %p [&quot; &quot;%016&quot; &quot;l&quot; &quot;x&quot; &quot;] index %d -&gt; %p [&quot; &quot;%016&quot; &quot;l&quot; &quot;x&quot; &quot;]\n&quot;, tb-&gt;tc_ptr, tb-&gt;pc, n, tb_next-&gt;tc_ptr, tb_next-&gt;pc); } } while (0)" data-ref="_M/qemu_log_mask_and_addr">qemu_log_mask_and_addr</a>(<a class="macro" href="../qemu/log.h.html#35" title="(1 &lt;&lt; 5)" data-ref="_M/CPU_LOG_EXEC">CPU_LOG_EXEC</a>, <a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::pc" title='TranslationBlock::pc' data-ref="TranslationBlock::pc">pc</a>,</td></tr>
<tr><th id="471">471</th><td>                           <q>"Linking TBs %p ["</q> <a class="macro" href="cpu-defs.h.html#52" title="&quot;%016&quot; &quot;l&quot; &quot;x&quot;" data-ref="_M/TARGET_FMT_lx">TARGET_FMT_lx</a></td></tr>
<tr><th id="472">472</th><td>                           <q>"] index %d -&gt; %p ["</q> <a class="macro" href="cpu-defs.h.html#52" title="&quot;%016&quot; &quot;l&quot; &quot;x&quot;" data-ref="_M/TARGET_FMT_lx">TARGET_FMT_lx</a> <q>"]\n"</q>,</td></tr>
<tr><th id="473">473</th><td>                           <a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::tc_ptr" title='TranslationBlock::tc_ptr' data-ref="TranslationBlock::tc_ptr">tc_ptr</a>, <a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::pc" title='TranslationBlock::pc' data-ref="TranslationBlock::pc">pc</a>, <a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a>,</td></tr>
<tr><th id="474">474</th><td>                           <a class="local col1 ref" href="#141tb_next" title='tb_next' data-ref="141tb_next">tb_next</a>-&gt;<a class="ref" href="#TranslationBlock::tc_ptr" title='TranslationBlock::tc_ptr' data-ref="TranslationBlock::tc_ptr">tc_ptr</a>, <a class="local col1 ref" href="#141tb_next" title='tb_next' data-ref="141tb_next">tb_next</a>-&gt;<a class="ref" href="#TranslationBlock::pc" title='TranslationBlock::pc' data-ref="TranslationBlock::pc">pc</a>);</td></tr>
<tr><th id="475">475</th><td></td></tr>
<tr><th id="476">476</th><td>    <i>/* patch the native jump address */</i></td></tr>
<tr><th id="477">477</th><td>    <a class="ref" href="#tb_set_jmp_target" title='tb_set_jmp_target' data-ref="tb_set_jmp_target">tb_set_jmp_target</a>(<a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>, <a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a>, (<a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a>)<a class="local col1 ref" href="#141tb_next" title='tb_next' data-ref="141tb_next">tb_next</a>-&gt;<a class="ref" href="#TranslationBlock::tc_ptr" title='TranslationBlock::tc_ptr' data-ref="TranslationBlock::tc_ptr">tc_ptr</a>);</td></tr>
<tr><th id="478">478</th><td></td></tr>
<tr><th id="479">479</th><td>    <i>/* add in TB jmp circular list */</i></td></tr>
<tr><th id="480">480</th><td>    <a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_list_next" title='TranslationBlock::jmp_list_next' data-ref="TranslationBlock::jmp_list_next">jmp_list_next</a>[<a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a>] = <a class="local col1 ref" href="#141tb_next" title='tb_next' data-ref="141tb_next">tb_next</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_list_first" title='TranslationBlock::jmp_list_first' data-ref="TranslationBlock::jmp_list_first">jmp_list_first</a>;</td></tr>
<tr><th id="481">481</th><td>    <a class="local col1 ref" href="#141tb_next" title='tb_next' data-ref="141tb_next">tb_next</a>-&gt;<a class="ref" href="#TranslationBlock::jmp_list_first" title='TranslationBlock::jmp_list_first' data-ref="TranslationBlock::jmp_list_first">jmp_list_first</a> = (<a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a>)<a class="local col9 ref" href="#139tb" title='tb' data-ref="139tb">tb</a> | <a class="local col0 ref" href="#140n" title='n' data-ref="140n">n</a>;</td></tr>
<tr><th id="482">482</th><td>}</td></tr>
<tr><th id="483">483</th><td></td></tr>
<tr><th id="484">484</th><td><i>/* GETPC is the true target of the return instruction that we'll execute.  */</i></td></tr>
<tr><th id="485">485</th><td><u>#<span data-ppcond="485">if</span> defined(<span class="macro" data-ref="_M/CONFIG_TCG_INTERPRETER">CONFIG_TCG_INTERPRETER</span>)</u></td></tr>
<tr><th id="486">486</th><td><b>extern</b> uintptr_t tci_tb_ptr;</td></tr>
<tr><th id="487">487</th><td><u># define GETPC() tci_tb_ptr</u></td></tr>
<tr><th id="488">488</th><td><u>#<span data-ppcond="485">else</span></u></td></tr>
<tr><th id="489">489</th><td><u># define <dfn class="macro" id="_M/GETPC" data-ref="_M/GETPC">GETPC</dfn>() \</u></td></tr>
<tr><th id="490">490</th><td><u>    ((uintptr_t)__builtin_extract_return_addr(__builtin_return_address(0)))</u></td></tr>
<tr><th id="491">491</th><td><u>#<span data-ppcond="485">endif</span></u></td></tr>
<tr><th id="492">492</th><td></td></tr>
<tr><th id="493">493</th><td><i>/* The true return address will often point to a host insn that is part of</i></td></tr>
<tr><th id="494">494</th><td><i>   the next translated guest insn.  Adjust the address backward to point to</i></td></tr>
<tr><th id="495">495</th><td><i>   the middle of the call insn.  Subtracting one would do the job except for</i></td></tr>
<tr><th id="496">496</th><td><i>   several compressed mode architectures (arm, mips) which set the low bit</i></td></tr>
<tr><th id="497">497</th><td><i>   to indicate the compressed mode; subtracting two works around that.  It</i></td></tr>
<tr><th id="498">498</th><td><i>   is also the case that there are no host isas that contain a call insn</i></td></tr>
<tr><th id="499">499</th><td><i>   smaller than 4 bytes, so we don't worry about special-casing this.  */</i></td></tr>
<tr><th id="500">500</th><td><u>#define <dfn class="macro" id="_M/GETPC_ADJ" data-ref="_M/GETPC_ADJ">GETPC_ADJ</dfn>   2</u></td></tr>
<tr><th id="501">501</th><td></td></tr>
<tr><th id="502">502</th><td><em>void</em> <dfn class="decl" id="tb_lock" title='tb_lock' data-ref="tb_lock">tb_lock</dfn>(<em>void</em>);</td></tr>
<tr><th id="503">503</th><td><em>void</em> <dfn class="decl" id="tb_unlock" title='tb_unlock' data-ref="tb_unlock">tb_unlock</dfn>(<em>void</em>);</td></tr>
<tr><th id="504">504</th><td><em>void</em> <dfn class="decl" id="tb_lock_reset" title='tb_lock_reset' data-ref="tb_lock_reset">tb_lock_reset</dfn>(<em>void</em>);</td></tr>
<tr><th id="505">505</th><td></td></tr>
<tr><th id="506">506</th><td><u>#<span data-ppcond="506">if</span> !defined(<span class="macro" data-ref="_M/CONFIG_USER_ONLY">CONFIG_USER_ONLY</span>)</u></td></tr>
<tr><th id="507">507</th><td></td></tr>
<tr><th id="508">508</th><td><b>struct</b> <a class="type" href="memory.h.html#MemoryRegion" title='MemoryRegion' data-ref="MemoryRegion">MemoryRegion</a> *<dfn class="decl" id="iotlb_to_region" title='iotlb_to_region' data-ref="iotlb_to_region">iotlb_to_region</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col2 decl" id="142cpu" title='cpu' data-type='CPUState *' data-ref="142cpu">cpu</dfn>,</td></tr>
<tr><th id="509">509</th><td>                                     <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col3 decl" id="143index" title='index' data-type='hwaddr' data-ref="143index">index</dfn>, <a class="typedef" href="memattrs.h.html#MemTxAttrs" title='MemTxAttrs' data-type='struct MemTxAttrs' data-ref="MemTxAttrs">MemTxAttrs</a> <dfn class="local col4 decl" id="144attrs" title='attrs' data-type='MemTxAttrs' data-ref="144attrs">attrs</dfn>);</td></tr>
<tr><th id="510">510</th><td></td></tr>
<tr><th id="511">511</th><td><em>void</em> <dfn class="decl" id="tlb_fill" title='tlb_fill' data-ref="tlb_fill">tlb_fill</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col5 decl" id="145cpu" title='cpu' data-type='CPUState *' data-ref="145cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col6 decl" id="146addr" title='addr' data-type='target_ulong' data-ref="146addr">addr</dfn>, <a class="typedef" href="../qom/cpu.h.html#MMUAccessType" title='MMUAccessType' data-type='enum MMUAccessType' data-ref="MMUAccessType">MMUAccessType</a> <dfn class="local col7 decl" id="147access_type" title='access_type' data-type='MMUAccessType' data-ref="147access_type">access_type</dfn>,</td></tr>
<tr><th id="512">512</th><td>              <em>int</em> <dfn class="local col8 decl" id="148mmu_idx" title='mmu_idx' data-type='int' data-ref="148mmu_idx">mmu_idx</dfn>, <a class="typedef" href="../../../include/stdint.h.html#uintptr_t" title='uintptr_t' data-type='unsigned long' data-ref="uintptr_t">uintptr_t</a> <dfn class="local col9 decl" id="149retaddr" title='retaddr' data-type='uintptr_t' data-ref="149retaddr">retaddr</dfn>);</td></tr>
<tr><th id="513">513</th><td></td></tr>
<tr><th id="514">514</th><td><u>#<span data-ppcond="506">endif</span></u></td></tr>
<tr><th id="515">515</th><td></td></tr>
<tr><th id="516">516</th><td><u>#<span data-ppcond="516">if</span> defined(<span class="macro" data-ref="_M/CONFIG_USER_ONLY">CONFIG_USER_ONLY</span>)</u></td></tr>
<tr><th id="517">517</th><td><em>void</em> mmap_lock(<em>void</em>);</td></tr>
<tr><th id="518">518</th><td><em>void</em> mmap_unlock(<em>void</em>);</td></tr>
<tr><th id="519">519</th><td>bool have_mmap_lock(<em>void</em>);</td></tr>
<tr><th id="520">520</th><td></td></tr>
<tr><th id="521">521</th><td><em>static</em> <b>inline</b> tb_page_addr_t get_page_addr_code(CPUArchState *env1, target_ulong addr)</td></tr>
<tr><th id="522">522</th><td>{</td></tr>
<tr><th id="523">523</th><td>    <b>return</b> addr;</td></tr>
<tr><th id="524">524</th><td>}</td></tr>
<tr><th id="525">525</th><td><u>#<span data-ppcond="516">else</span></u></td></tr>
<tr><th id="526">526</th><td><em>static</em> <b>inline</b> <em>void</em> <dfn class="decl def" id="mmap_lock" title='mmap_lock' data-ref="mmap_lock">mmap_lock</dfn>(<em>void</em>) {}</td></tr>
<tr><th id="527">527</th><td><em>static</em> <b>inline</b> <em>void</em> <dfn class="decl def" id="mmap_unlock" title='mmap_unlock' data-ref="mmap_unlock">mmap_unlock</dfn>(<em>void</em>) {}</td></tr>
<tr><th id="528">528</th><td></td></tr>
<tr><th id="529">529</th><td><i>/* cputlb.c */</i></td></tr>
<tr><th id="530">530</th><td><a class="typedef" href="#tb_page_addr_t" title='tb_page_addr_t' data-type='ram_addr_t' data-ref="tb_page_addr_t">tb_page_addr_t</a> <dfn class="decl" id="get_page_addr_code" title='get_page_addr_code' data-ref="get_page_addr_code">get_page_addr_code</dfn>(<a class="macro" href="../../target/i386/cpu.h.html#51" title="struct CPUX86State" data-ref="_M/CPUArchState">CPUArchState</a> *<dfn class="local col0 decl" id="150env1" title='env1' data-type='struct CPUX86State *' data-ref="150env1">env1</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col1 decl" id="151addr" title='addr' data-type='target_ulong' data-ref="151addr">addr</dfn>);</td></tr>
<tr><th id="531">531</th><td></td></tr>
<tr><th id="532">532</th><td><em>void</em> <dfn class="decl" id="tlb_reset_dirty" title='tlb_reset_dirty' data-ref="tlb_reset_dirty">tlb_reset_dirty</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col2 decl" id="152cpu" title='cpu' data-type='CPUState *' data-ref="152cpu">cpu</dfn>, <a class="typedef" href="cpu-common.h.html#ram_addr_t" title='ram_addr_t' data-type='uintptr_t' data-ref="ram_addr_t">ram_addr_t</a> <dfn class="local col3 decl" id="153start1" title='start1' data-type='ram_addr_t' data-ref="153start1">start1</dfn>, <a class="typedef" href="cpu-common.h.html#ram_addr_t" title='ram_addr_t' data-type='uintptr_t' data-ref="ram_addr_t">ram_addr_t</a> <dfn class="local col4 decl" id="154length" title='length' data-type='ram_addr_t' data-ref="154length">length</dfn>);</td></tr>
<tr><th id="533">533</th><td><em>void</em> <dfn class="decl" id="tlb_set_dirty" title='tlb_set_dirty' data-ref="tlb_set_dirty">tlb_set_dirty</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col5 decl" id="155cpu" title='cpu' data-type='CPUState *' data-ref="155cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col6 decl" id="156vaddr" title='vaddr' data-type='target_ulong' data-ref="156vaddr">vaddr</dfn>);</td></tr>
<tr><th id="534">534</th><td></td></tr>
<tr><th id="535">535</th><td><i>/* exec.c */</i></td></tr>
<tr><th id="536">536</th><td><em>void</em> <dfn class="decl" id="tb_flush_jmp_cache" title='tb_flush_jmp_cache' data-ref="tb_flush_jmp_cache">tb_flush_jmp_cache</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col7 decl" id="157cpu" title='cpu' data-type='CPUState *' data-ref="157cpu">cpu</dfn>, <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col8 decl" id="158addr" title='addr' data-type='target_ulong' data-ref="158addr">addr</dfn>);</td></tr>
<tr><th id="537">537</th><td></td></tr>
<tr><th id="538">538</th><td><a class="typedef" href="../qemu/typedefs.h.html#MemoryRegionSection" title='MemoryRegionSection' data-type='struct MemoryRegionSection' data-ref="MemoryRegionSection">MemoryRegionSection</a> *</td></tr>
<tr><th id="539">539</th><td><dfn class="decl" id="address_space_translate_for_iotlb" title='address_space_translate_for_iotlb' data-ref="address_space_translate_for_iotlb">address_space_translate_for_iotlb</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col9 decl" id="159cpu" title='cpu' data-type='CPUState *' data-ref="159cpu">cpu</dfn>, <em>int</em> <dfn class="local col0 decl" id="160asidx" title='asidx' data-type='int' data-ref="160asidx">asidx</dfn>, <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col1 decl" id="161addr" title='addr' data-type='hwaddr' data-ref="161addr">addr</dfn>,</td></tr>
<tr><th id="540">540</th><td>                                  <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> *<dfn class="local col2 decl" id="162xlat" title='xlat' data-type='hwaddr *' data-ref="162xlat">xlat</dfn>, <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> *<dfn class="local col3 decl" id="163plen" title='plen' data-type='hwaddr *' data-ref="163plen">plen</dfn>);</td></tr>
<tr><th id="541">541</th><td><a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="decl" id="memory_region_section_get_iotlb" title='memory_region_section_get_iotlb' data-ref="memory_region_section_get_iotlb">memory_region_section_get_iotlb</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#CPUState" title='CPUState' data-type='struct CPUState' data-ref="CPUState">CPUState</a> *<dfn class="local col4 decl" id="164cpu" title='cpu' data-type='CPUState *' data-ref="164cpu">cpu</dfn>,</td></tr>
<tr><th id="542">542</th><td>                                       <a class="typedef" href="../qemu/typedefs.h.html#MemoryRegionSection" title='MemoryRegionSection' data-type='struct MemoryRegionSection' data-ref="MemoryRegionSection">MemoryRegionSection</a> *<dfn class="local col5 decl" id="165section" title='section' data-type='MemoryRegionSection *' data-ref="165section">section</dfn>,</td></tr>
<tr><th id="543">543</th><td>                                       <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> <dfn class="local col6 decl" id="166vaddr" title='vaddr' data-type='target_ulong' data-ref="166vaddr">vaddr</dfn>,</td></tr>
<tr><th id="544">544</th><td>                                       <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col7 decl" id="167paddr" title='paddr' data-type='hwaddr' data-ref="167paddr">paddr</dfn>, <a class="typedef" href="hwaddr.h.html#hwaddr" title='hwaddr' data-type='uint64_t' data-ref="hwaddr">hwaddr</a> <dfn class="local col8 decl" id="168xlat" title='xlat' data-type='hwaddr' data-ref="168xlat">xlat</dfn>,</td></tr>
<tr><th id="545">545</th><td>                                       <em>int</em> <dfn class="local col9 decl" id="169prot" title='prot' data-type='int' data-ref="169prot">prot</dfn>,</td></tr>
<tr><th id="546">546</th><td>                                       <a class="typedef" href="cpu-defs.h.html#target_ulong" title='target_ulong' data-type='uint64_t' data-ref="target_ulong">target_ulong</a> *<dfn class="local col0 decl" id="170address" title='address' data-type='target_ulong *' data-ref="170address">address</dfn>);</td></tr>
<tr><th id="547">547</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="memory_region_is_unassigned" title='memory_region_is_unassigned' data-ref="memory_region_is_unassigned">memory_region_is_unassigned</dfn>(<a class="typedef" href="../qemu/typedefs.h.html#MemoryRegion" title='MemoryRegion' data-type='struct MemoryRegion' data-ref="MemoryRegion">MemoryRegion</a> *<dfn class="local col1 decl" id="171mr" title='mr' data-type='MemoryRegion *' data-ref="171mr">mr</dfn>);</td></tr>
<tr><th id="548">548</th><td></td></tr>
<tr><th id="549">549</th><td><u>#<span data-ppcond="516">endif</span></u></td></tr>
<tr><th id="550">550</th><td></td></tr>
<tr><th id="551">551</th><td><i>/* vl.c */</i></td></tr>
<tr><th id="552">552</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="singlestep" title='singlestep' data-ref="singlestep">singlestep</dfn>;</td></tr>
<tr><th id="553">553</th><td></td></tr>
<tr><th id="554">554</th><td><u>#<span data-ppcond="20">endif</span></u></td></tr>
<tr><th id="555">555</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../accel/tcg/cpu-exec-common.c.html'>codebrowser/accel/tcg/cpu-exec-common.c</a><br/>Generated on <em>2017-Aug-28</em> from project codebrowser revision <em>v2.10.0-rc0-7-g6be37cc</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
